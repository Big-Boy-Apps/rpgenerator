package com.rpgenerator.core.domain

import kotlinx.serialization.Serializable
import com.rpgenerator.core.util.currentTimeMillis

/**
 * Agent Memory Persistence Domain Classes
 *
 * This system allows AI agents to persist their conversation history and important decisions
 * across game sessions. Agents can save their state, load it on initialization, and consolidate
 * old memories to manage context window size.
 *
 * Architecture:
 * - AgentMemory: Full conversation history for an agent in a specific game
 * - AgentAction: Individual important decisions/actions with reasoning
 * - ConsolidationSnapshot: Summarized context from old consolidated messages
 */

/**
 * Agent conversation memory and state.
 * Stores the complete message history for an agent in a game session.
 *
 * Usage:
 * - Load when agent initializes for a game session
 * - Update after significant interactions
 * - Consolidate when token count gets too high
 */
@Serializable
data class AgentMemory(
    val agentId: String,                    // "game_master", "planner", "npc_merchant_001", etc.
    val gameId: String,
    val messages: List<AgentMessage>,       // Full conversation history
    val consolidatedContext: String? = null, // Summarized context from previous consolidations
    val lastConsolidated: Long? = null,     // Timestamp of last consolidation
    val metadata: AgentMemoryMetadata = AgentMemoryMetadata()
) {
    /**
     * Estimated token count for the entire memory.
     * Rough estimate: ~4 characters per token
     */
    fun estimateTokens(): Int {
        val messageTokens = messages.sumOf { it.estimateTokens() }
        val contextTokens = (consolidatedContext?.length ?: 0) / 4
        return messageTokens + contextTokens
    }

    /**
     * Check if memory needs consolidation based on token limit.
     */
    fun needsConsolidation(tokenLimit: Int = 50000): Boolean {
        return estimateTokens() > tokenLimit
    }

    /**
     * Add a new message to the conversation history.
     */
    fun addMessage(message: AgentMessage): AgentMemory {
        return copy(
            messages = messages + message,
            metadata = metadata.copy(lastUpdated = currentTimeMillis())
        )
    }

    /**
     * Create a consolidation by summarizing old messages.
     * Keeps recent messages and consolidates the rest into a summary.
     *
     * @param keepRecentCount How many recent messages to preserve
     * @param summary Summarized context from consolidated messages
     */
    fun consolidate(keepRecentCount: Int, summary: String): AgentMemory {
        val recentMessages = messages.takeLast(keepRecentCount)
        return copy(
            messages = recentMessages,
            consolidatedContext = summary,
            lastConsolidated = currentTimeMillis(),
            metadata = metadata.copy(
                consolidationCount = metadata.consolidationCount + 1,
                lastUpdated = currentTimeMillis()
            )
        )
    }
}

/**
 * Individual message in agent conversation history.
 */
@Serializable
data class AgentMessage(
    val role: AgentRole,
    val content: String,
    val timestamp: Long = currentTimeMillis()
) {
    fun estimateTokens(): Int = content.length / 4
}

/**
 * Role in agent conversation.
 */
@Serializable
enum class AgentRole {
    SYSTEM,     // System prompt
    USER,       // Input to agent (game state, player action, etc.)
    ASSISTANT   // Agent's response
}

/**
 * Metadata about agent memory state.
 */
@Serializable
data class AgentMemoryMetadata(
    val createdAt: Long = currentTimeMillis(),
    val lastUpdated: Long = currentTimeMillis(),
    val consolidationCount: Int = 0,
    val totalInteractions: Int = 0
)

/**
 * Individual agent action with reasoning.
 * Logs important decisions made by agents for analysis and debugging.
 *
 * Examples:
 * - GameMaster creates an NPC
 * - Planner generates a plot thread
 * - NPCAgent makes a significant dialogue choice
 */
@Serializable
data class AgentAction(
    val id: Long? = null,               // Auto-generated by database
    val agentId: String,
    val gameId: String,
    val actionType: AgentActionType,
    val actionData: String,             // JSON-serialized action-specific data
    val reasoning: String,              // Why the agent made this decision
    val context: AgentActionContext,
    val timestamp: Long = currentTimeMillis()
)

/**
 * Context when action was taken.
 */
@Serializable
data class AgentActionContext(
    val playerLevel: Int,
    val npcId: String? = null,
    val questId: String? = null,
    val plotThreadId: String? = null,
    val locationId: String? = null
)

/**
 * Types of actions agents can log.
 */
@Serializable
enum class AgentActionType {
    // GameMaster actions
    NPC_CREATED,
    QUEST_GENERATED,
    ENCOUNTER_TRIGGERED,
    NARRATIVE_CHOICE,

    // Planner actions
    PLOT_THREAD_CREATED,
    PLOT_THREAD_UPDATED,
    PLOT_THREAD_ABANDONED,
    PLOT_BEAT_TRIGGERED,
    TRAJECTORY_ANALYZED,

    // NPC Agent actions
    DIALOGUE_GENERATED,
    RELATIONSHIP_CHANGED,
    NPC_DECISION,

    // System Agent actions
    GRADE_ADVANCEMENT,
    SKILL_UNLOCKED,
    LOOT_GENERATED,

    // Generic
    AGENT_DECISION,
    ERROR_HANDLED
}

/**
 * Snapshot of consolidated agent memory.
 * Created when agent memory is summarized to reduce token count.
 */
@Serializable
data class ConsolidationSnapshot(
    val id: Long? = null,
    val agentId: String,
    val gameId: String,
    val consolidationType: ConsolidationType,
    val summary: String,                    // Summarized context
    val messagesConsolidated: Int,          // How many messages were compressed
    val playerLevelStart: Int,              // Player level range start
    val playerLevelEnd: Int,                // Player level range end
    val timestamp: Long = currentTimeMillis()
) {
    /**
     * Convenience property for level range.
     */
    val levelRange: IntRange get() = playerLevelStart..playerLevelEnd
}

/**
 * Type of consolidation performed.
 */
@Serializable
enum class ConsolidationType {
    /**
     * Partial consolidation: Summarize old messages, keep recent ones.
     * Used when context is getting too large but we want to preserve recent history.
     */
    PARTIAL,

    /**
     * Full consolidation: Complete reset with comprehensive summary.
     * Used at major story milestones or when starting a new tier.
     */
    FULL
}

/**
 * Result of a consolidation operation.
 */
data class ConsolidationResult(
    val updatedMemory: AgentMemory,
    val snapshot: ConsolidationSnapshot,
    val tokensBefore: Int,
    val tokensAfter: Int,
    val messagesBefore: Int,
    val messagesAfter: Int
)

/**
 * Configuration for agent memory management.
 */
data class AgentMemoryConfig(
    val tokenLimit: Int = 50000,           // Trigger consolidation at this limit
    val keepRecentMessages: Int = 20,      // Keep this many recent messages after consolidation
    val autoSaveInterval: Int = 5,         // Auto-save every N interactions
    val enableActionLogging: Boolean = true // Log important actions
)
